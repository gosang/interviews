
Implementation Overview
This implementation provides a complete authentication solution for your Request Document Site using ForgeRock Identity with NextAuth.js. Here's what it includes:
Key Features:

Authorization Code Flow with PKCE: Implemented through NextAuth.js custom OAuth provider
Token Management: Automatic token refresh and secure storage
Protected Routes: Middleware and component-level protection
Error Handling: Comprehensive error pages and handling
TypeScript Support: Full type safety throughout

Setup Instructions:

Install Dependencies:

bashnpm install next-auth @forgerock/javascript-sdk
npm install -D @types/node @types/react @types/react-dom typescript

Environment Configuration:

Copy the .env.local variables and update with your ForgeRock tenant details
Set NEXTAUTH_SECRET to a secure random string
Configure your ForgeRock OAuth client with the correct redirect URI


ForgeRock Configuration:

Ensure your ForgeRock OAuth client is configured for Authorization Code flow with PKCE
Set the redirect URI to: https://yourdomain.com/api/auth/callback/forgerock
Enable the required scopes: openid profile email


How the Flow Works:

Initial Redirect: User comes from your centralized auth site with code and state parameters
Callback Handling: The /api/auth/callback endpoint processes these parameters
Token Exchange: NextAuth.js handles the PKCE code exchange with ForgeRock
Session Management: JWT tokens are securely stored and automatically refreshed
Route Protection: Middleware and components protect authenticated routes

Usage Examples:

Protect a page: Wrap with <ProtectedRoute>
Check auth status: Use the useAuth() hook
Make API calls: Use the authenticated apiClient
Handle redirects: Automatic handling of auth state and redirects

The implementation handles all the complex OAuth flows, token management, and provides a clean interface for your application to work with authenticated users. The middleware ensures that protected routes automatically redirect unauthenticated users to the sign-in page.


// types/next-auth.d.ts
import { DefaultSession, DefaultUser } from "next-auth"
import { JWT, DefaultJWT } from "next-auth/jwt"

declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string
      email: string
      name: string
      accessToken: string
      refreshToken: string
    } & DefaultSession["user"]
  }

  interface User extends DefaultUser {
    accessToken: string
    refreshToken: string
  }
}

declare module "next-auth/jwt" {
  interface JWT extends DefaultJWT {
    accessToken: string
    refreshToken: string
    accessTokenExpires: number
  }
}

// lib/forgerock-provider.ts
import { OAuthConfig, OAuthUserConfig } from "next-auth/providers"
import { generateCodeChallenge, generateCodeVerifier } from "./pkce-utils"

export interface ForgeRockProfile {
  sub: string
  name: string
  email: string
  preferred_username: string
  given_name: string
  family_name: string
}

export interface ForgeRockProvider extends OAuthUserConfig<ForgeRockProfile> {
  tenantBaseUrl: string
}

export default function ForgeRock(options: ForgeRockProvider): OAuthConfig<ForgeRockProfile> {
  const { tenantBaseUrl, ...config } = options

  return {
    id: "forgerock",
    name: "ForgeRock",
    type: "oauth",
    version: "2.0",
    authorization: {
      url: `${tenantBaseUrl}/oauth2/authorize`,
      params: {
        scope: "openid profile email",
        response_type: "code",
        code_challenge_method: "S256",
      },
    },
    token: `${tenantBaseUrl}/oauth2/access_token`,
    userinfo: `${tenantBaseUrl}/oauth2/userinfo`,
    profile(profile: ForgeRockProfile) {
      return {
        id: profile.sub,
        name: profile.name || profile.preferred_username,
        email: profile.email,
        image: null,
      }
    },
    options: {
      ...config,
    },
  }
}

// lib/pkce-utils.ts
import crypto from 'crypto'

export function generateCodeVerifier(): string {
  return crypto.randomBytes(32).toString('base64url')
}

export function generateCodeChallenge(codeVerifier: string): string {
  return crypto.createHash('sha256').update(codeVerifier).digest('base64url')
}

// lib/auth.ts
import NextAuth, { NextAuthOptions } from "next-auth"
import ForgeRock from "./forgerock-provider"
import { JWT } from "next-auth/jwt"

const FORGEROCK_TENANT_BASE_URL = process.env.FORGEROCK_TENANT_BASE_URL!
const FORGEROCK_CLIENT_ID = process.env.FORGEROCK_CLIENT_ID!
const FORGEROCK_CLIENT_SECRET = process.env.FORGEROCK_CLIENT_SECRET!

async function refreshAccessToken(token: JWT): Promise<JWT> {
  try {
    const url = `${FORGEROCK_TENANT_BASE_URL}/oauth2/access_token`
    
    const response = await fetch(url, {
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `Basic ${Buffer.from(`${FORGEROCK_CLIENT_ID}:${FORGEROCK_CLIENT_SECRET}`).toString("base64")}`,
      },
      method: "POST",
      body: new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: token.refreshToken,
      }),
    })

    const refreshedTokens = await response.json()

    if (!response.ok) {
      throw refreshedTokens
    }

    return {
      ...token,
      accessToken: refreshedTokens.access_token,
      accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000,
      refreshToken: refreshedTokens.refresh_token ?? token.refreshToken,
    }
  } catch (error) {
    console.error("Error refreshing access token:", error)
    return {
      ...token,
      error: "RefreshAccessTokenError",
    }
  }
}

export const authOptions: NextAuthOptions = {
  providers: [
    ForgeRock({
      tenantBaseUrl: FORGEROCK_TENANT_BASE_URL,
      clientId: FORGEROCK_CLIENT_ID,
      clientSecret: FORGEROCK_CLIENT_SECRET,
      authorization: {
        params: {
          scope: "openid profile email",
          response_type: "code",
          code_challenge_method: "S256",
        },
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user, account }) {
      // Initial sign in
      if (account && user) {
        return {
          ...token,
          accessToken: account.access_token!,
          refreshToken: account.refresh_token!,
          accessTokenExpires: account.expires_at! * 1000,
        }
      }

      // Return previous token if the access token has not expired yet
      if (Date.now() < token.accessTokenExpires) {
        return token
      }

      // Access token has expired, try to update it
      return refreshAccessToken(token)
    },
    async session({ session, token }) {
      if (token) {
        session.user.id = token.sub!
        session.user.accessToken = token.accessToken
        session.user.refreshToken = token.refreshToken
      }
      return session
    },
    async redirect({ url, baseUrl }) {
      // Handle redirects after authentication
      if (url.startsWith("/")) return `${baseUrl}${url}`
      else if (new URL(url).origin === baseUrl) return url
      return baseUrl
    },
  },
  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
  },
  session: {
    strategy: "jwt",
  },
  debug: process.env.NODE_ENV === "development",
}

export default NextAuth(authOptions)

// pages/api/auth/[...nextauth].ts
import NextAuth from "next-auth"
import { authOptions } from "../../../lib/auth"

export default NextAuth(authOptions)

// pages/api/auth/callback.ts
import { NextApiRequest, NextApiResponse } from 'next'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '../../../lib/auth'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { code, state, error } = req.query

  if (error) {
    return res.redirect(`/auth/error?error=${encodeURIComponent(error as string)}`)
  }

  if (!code || !state) {
    return res.redirect('/auth/error?error=missing_parameters')
  }

  try {
    // The NextAuth.js OAuth flow will handle the code exchange
    // We just need to redirect to the callback URL that NextAuth expects
    const callbackUrl = `/api/auth/callback/forgerock?code=${code}&state=${state}`
    return res.redirect(callbackUrl)
  } catch (error) {
    console.error('Auth callback error:', error)
    return res.redirect('/auth/error?error=callback_failed')
  }
}

// components/AuthProvider.tsx
"use client"

import { SessionProvider } from "next-auth/react"
import { ReactNode } from "react"

interface AuthProviderProps {
  children: ReactNode
}

export default function AuthProvider({ children }: AuthProviderProps) {
  return <SessionProvider>{children}</SessionProvider>
}

// components/ProtectedRoute.tsx
"use client"

import { useSession } from "next-auth/react"
import { useRouter } from "next/navigation"
import { useEffect, ReactNode } from "react"

interface ProtectedRouteProps {
  children: ReactNode
  redirectTo?: string
}

export default function ProtectedRoute({ 
  children, 
  redirectTo = "/auth/signin" 
}: ProtectedRouteProps) {
  const { data: session, status } = useSession()
  const router = useRouter()

  useEffect(() => {
    if (status === "loading") return // Still loading

    if (!session) {
      router.push(redirectTo)
    }
  }, [session, status, router, redirectTo])

  if (status === "loading") {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
      </div>
    )
  }

  if (!session) {
    return null
  }

  return <>{children}</>
}

// hooks/useAuth.ts
import { useSession, signIn, signOut } from "next-auth/react"
import { useRouter } from "next/navigation"

export function useAuth() {
  const { data: session, status } = useSession()
  const router = useRouter()

  const login = async (redirectTo?: string) => {
    await signIn("forgerock", { 
      callbackUrl: redirectTo || window.location.href 
    })
  }

  const logout = async (redirectTo?: string) => {
    await signOut({ 
      callbackUrl: redirectTo || "/" 
    })
  }

  return {
    user: session?.user || null,
    isLoading: status === "loading",
    isAuthenticated: !!session,
    login,
    logout,
  }
}

// pages/auth/signin.tsx
import { GetServerSideProps } from 'next'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '../../lib/auth'
import { useAuth } from '../../hooks/useAuth'
import { useEffect } from 'react'

export default function SignIn() {
  const { login, isLoading } = useAuth()

  useEffect(() => {
    // Automatically trigger ForgeRock login
    if (!isLoading) {
      login()
    }
  }, [login, isLoading])

  return (
    <div className="flex justify-center items-center min-h-screen">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">Redirecting to ForgeRock...</h1>
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div>
      </div>
    </div>
  )
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const session = await getServerSession(context.req, context.res, authOptions)

  if (session) {
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    }
  }

  return {
    props: {},
  }
}

// pages/auth/error.tsx
import { useRouter } from 'next/router'
import Link from 'next/link'

export default function AuthError() {
  const router = useRouter()
  const { error } = router.query

  const getErrorMessage = (error: string | string[] | undefined) => {
    if (!error || Array.isArray(error)) return 'An unknown error occurred'
    
    switch (error) {
      case 'Configuration':
        return 'There is a problem with the server configuration.'
      case 'AccessDenied':
        return 'Access denied. You do not have permission to sign in.'
      case 'Verification':
        return 'The sign-in link is no longer valid. It may have expired.'
      case 'missing_parameters':
        return 'Missing required parameters for authentication.'
      case 'callback_failed':
        return 'Authentication callback failed. Please try again.'
      default:
        return `Authentication error: ${error}`
    }
  }

  return (
    <div className="flex justify-center items-center min-h-screen">
      <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
        <div className="text-center">
          <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
            <svg className="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
            </svg>
          </div>
          <h3 className="mt-2 text-sm font-medium text-gray-900">Authentication Error</h3>
          <p className="mt-1 text-sm text-gray-500">{getErrorMessage(error)}</p>
          <div className="mt-6">
            <Link 
              href="/auth/signin"
              className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Try Again
            </Link>
          </div>
        </div>
      </div>
    </div>
  )
}

// app/layout.tsx (for App Router)
import AuthProvider from '../components/AuthProvider'
import './globals.css'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  )
}

// app/dashboard/page.tsx (Protected Dashboard Example)
"use client"

import ProtectedRoute from '../../components/ProtectedRoute'
import { useAuth } from '../../hooks/useAuth'

export default function Dashboard() {
  const { user, logout } = useAuth()

  return (
    <ProtectedRoute>
      <div className="min-h-screen bg-gray-50">
        <nav className="bg-white shadow">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex justify-between h-16">
              <div className="flex items-center">
                <h1 className="text-xl font-semibold">Request Document Site</h1>
              </div>
              <div className="flex items-center space-x-4">
                <span className="text-sm text-gray-700">Welcome, {user?.name}</span>
                <button
                  onClick={() => logout()}
                  className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
                >
                  Logout
                </button>
              </div>
            </div>
          </div>
        </nav>

        <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
          <div className="px-4 py-6 sm:px-0">
            <div className="border-4 border-dashed border-gray-200 rounded-lg p-8">
              <h2 className="text-2xl font-bold mb-4">Protected Dashboard</h2>
              <p className="text-gray-600 mb-4">
                You have successfully authenticated with ForgeRock Identity.
              </p>
              <div className="bg-gray-100 p-4 rounded">
                <h3 className="font-semibold mb-2">User Information:</h3>
                <p><strong>ID:</strong> {user?.id}</p>
                <p><strong>Name:</strong> {user?.name}</p>
                <p><strong>Email:</strong> {user?.email}</p>
              </div>
            </div>
          </div>
        </main>
      </div>
    </ProtectedRoute>
  )
}

// .env.local (Environment Configuration)
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-nextauth-secret-here

# ForgeRock Configuration
FORGEROCK_TENANT_BASE_URL=https://your-tenant.forgerock.com/am
FORGEROCK_CLIENT_ID=your-client-id
FORGEROCK_CLIENT_SECRET=your-client-secret

# package.json dependencies
{
  "dependencies": {
    "next": "^14.0.0",
    "next-auth": "^4.24.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "@forgerock/javascript-sdk": "^4.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "typescript": "^5.0.0"
  }
}

// middleware.ts (Route Protection Middleware)
import { withAuth } from "next-auth/middleware"

export default withAuth(
  function middleware(req) {
    // Add any custom middleware logic here
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        // Protect specific routes
        if (req.nextUrl.pathname.startsWith('/dashboard')) {
          return !!token
        }
        if (req.nextUrl.pathname.startsWith('/documents')) {
          return !!token
        }
        return true
      },
    },
  }
)

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/documents/:path*',
    '/api/protected/:path*'
  ]
}

// lib/forgerock-sdk.ts (Optional: Direct ForgeRock SDK Integration)
import { Config, FRAuth, TokenManager } from '@forgerock/javascript-sdk'

// Configure ForgeRock SDK
Config.set({
  clientId: process.env.FORGEROCK_CLIENT_ID!,
  redirectUri: `${process.env.NEXTAUTH_URL}/api/auth/callback`,
  scope: 'openid profile email',
  serverConfig: {
    baseUrl: process.env.FORGEROCK_TENANT_BASE_URL!,
  },
  realmPath: 'alpha', // Adjust based on your ForgeRock realm
})

export class ForgeRockService {
  static async getAccessToken(): Promise<string | null> {
    try {
      const tokens = await TokenManager.getTokens()
      return tokens?.accessToken || null
    } catch (error) {
      console.error('Error getting access token:', error)
      return null
    }
  }

  static async refreshTokens(): Promise<boolean> {
    try {
      await TokenManager.refresh()
      return true
    } catch (error) {
      console.error('Error refreshing tokens:', error)
      return false
    }
  }

  static async logout(): Promise<void> {
    try {
      await FRAuth.logout()
    } catch (error) {
      console.error('Error during logout:', error)
    }
  }
}

// utils/api-client.ts (Authenticated API Client)
import { getSession } from 'next-auth/react'

class ApiClient {
  private baseUrl: string

  constructor(baseUrl: string = process.env.NEXT_PUBLIC_API_BASE_URL || '') {
    this.baseUrl = baseUrl
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const session = await getSession()
    
    if (session?.user?.accessToken) {
      return {
        'Authorization': `Bearer ${session.user.accessToken}`,
        'Content-Type': 'application/json',
      }
    }
    
    return {
      'Content-Type': 'application/json',
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    const headers = await this.getAuthHeaders()
    
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'GET',
      headers,
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return response.json()
  }

  async post<T>(endpoint: string, data: any): Promise<T> {
    const headers = await this.getAuthHeaders()
    
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    })

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`)
    }

    return response.json()
  }

  // Add other HTTP methods as needed (PUT, DELETE, etc.)
}

export const apiClient = new ApiClient()