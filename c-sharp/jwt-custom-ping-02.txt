-----

using client_api.Services;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace client_api.Controllers;

[Route("api/[controller]")]
[ApiController]
public class ClientController : ControllerBase
{
    private readonly ITokenService _tokenService;
    private readonly IProtectedApiClient _protectedApiClient;
    private readonly ILogger<ClientController> _logger;

    public ClientController(
        ITokenService tokenService,
        IProtectedApiClient protectedApiClient,
        ILogger<ClientController> logger)
    {
        _tokenService = tokenService;
        _protectedApiClient = protectedApiClient;
        _logger = logger;
    }

    /// <summary>
    /// Get an access token from Ping Identity
    /// </summary>
    [HttpGet("token")]
    [ProducesResponseType(typeof(TokenResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> GetToken(CancellationToken cancellationToken)
    {
        try
        {
            var tokenResponse = await _tokenService.GetAccessTokenAsync(cancellationToken);

            return Ok(new TokenResponseDto
            {
                AccessToken = tokenResponse.AccessToken,
                TokenType = tokenResponse.TokenType,
                ExpiresIn = tokenResponse.ExpiresIn,
                Scope = tokenResponse.Scope
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to obtain access token");
            return StatusCode(500, new ErrorResponse
            {
                Error = "token_acquisition_failed",
                Message = "Failed to obtain access token",
                Details = ex.Message
            });
        }
    }

    /// <summary>
    /// Force refresh the access token
    /// </summary>
    [HttpPost("token/refresh")]
    [ProducesResponseType(typeof(TokenResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> RefreshToken(CancellationToken cancellationToken)
    {
        try
        {
            var tokenResponse = await _tokenService.RefreshTokenAsync(cancellationToken);

            return Ok(new TokenResponseDto
            {
                AccessToken = tokenResponse.AccessToken,
                TokenType = tokenResponse.TokenType,
                ExpiresIn = tokenResponse.ExpiresIn,
                Scope = tokenResponse.Scope
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to refresh access token");
            return StatusCode(500, new ErrorResponse
            {
                Error = "token_refresh_failed",
                Message = "Failed to refresh access token",
                Details = ex.Message
            });
        }
    }

    /// <summary>
    /// Call protected API to get weather data
    /// </summary>
    [HttpGet("weather")]
    [ProducesResponseType(typeof(List<WeatherForecast>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> GetWeather(
        [FromQuery] int days = 5,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var weather = await _protectedApiClient.GetAsync<List<WeatherForecast>>(
                $"/api/weather?days={days}",
                cancellationToken);

            return Ok(weather);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "Failed to call protected API");
            return StatusCode(500, new ErrorResponse
            {
                Error = "api_call_failed",
                Message = "Failed to retrieve weather data from protected API",
                Details = ex.Message
            });
        }
    }

    /// <summary>
    /// Call protected API with POST request
    /// </summary>
    [HttpPost("weather")]
    [ProducesResponseType(typeof(WeatherForecast), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> CreateWeather(
        [FromBody] WeatherForecast forecast,
        CancellationToken cancellationToken)
    {
        try
        {
            var result = await _protectedApiClient.PostAsync<WeatherForecast, WeatherForecast>(
                "/api/weather",
                forecast,
                cancellationToken);

            return Ok(result);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "Failed to create weather forecast");
            return StatusCode(500, new ErrorResponse
            {
                Error = "api_call_failed",
                Message = "Failed to create weather forecast",
                Details = ex.Message
            });
        }
    }

    /// <summary>
    /// Get any data from protected API
    /// </summary>
    [HttpGet("proxy/{*endpoint}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> ProxyGet(
        string endpoint,
        CancellationToken cancellationToken)
    {
        try
        {
            var result = await _protectedApiClient.GetAsync<object>(
                $"/{endpoint}",
                cancellationToken);

            return Ok(result);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "Failed to proxy GET request to {Endpoint}", endpoint);
            return StatusCode(500, new ErrorResponse
            {
                Error = "api_call_failed",
                Message = $"Failed to call protected API endpoint: {endpoint}",
                Details = ex.Message
            });
        }
    }

    /// <summary>
    /// Health check endpoint
    /// </summary>
    [HttpGet("health")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    public IActionResult Health()
    {
        return Ok(new { Status = "Healthy", Timestamp = DateTime.UtcNow });
    }
}

// DTOs
public class TokenResponseDto
{
    public string AccessToken { get; set; } = string.Empty;
    public string TokenType { get; set; } = string.Empty;
    public int ExpiresIn { get; set; }
    public string? Scope { get; set; }
}

public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; set; }
}

public class ErrorResponse
{
    public string Error { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public string? Details { get; set; }
}

-----

using Microsoft.Extensions.Options;
using System.Net;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

namespace client_api.Services;

public interface IProtectedApiClient
{
    Task<T?> GetAsync<T>(string endpoint, CancellationToken cancellationToken = default);
    Task<TResponse?> PostAsync<TRequest, TResponse>(string endpoint, TRequest data, CancellationToken cancellationToken = default);
    Task<TResponse?> PutAsync<TRequest, TResponse>(string endpoint, TRequest data, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string endpoint, CancellationToken cancellationToken = default);
}

public class ProtectedApiClient : IProtectedApiClient
{
    private readonly HttpClient _httpClient;
    private readonly ITokenService _tokenService;
    private readonly PingIdentityOptions _options;
    private readonly ILogger<ProtectedApiClient> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public ProtectedApiClient(
        HttpClient httpClient,
        ITokenService tokenService,
        IOptions<PingIdentityOptions> options,
        ILogger<ProtectedApiClient> logger)
    {
        _httpClient = httpClient;
        _tokenService = tokenService;
        _options = options.Value;
        _logger = logger;

        // Configure base address
        if (!string.IsNullOrEmpty(_options.ProtectedApiBaseUrl))
        {
            _httpClient.BaseAddress = new Uri(_options.ProtectedApiBaseUrl);
        }

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    public async Task<T?> GetAsync<T>(string endpoint, CancellationToken cancellationToken = default)
    {
        return await ExecuteWithRetryAsync<T>(
            async () =>
            {
                await SetAuthorizationHeaderAsync(cancellationToken);

                _logger.LogInformation("Calling GET {Endpoint}", endpoint);

                var response = await _httpClient.GetAsync(endpoint, cancellationToken);
                return await HandleResponseAsync<T>(response, cancellationToken);
            },
            cancellationToken);
    }

    public async Task<TResponse?> PostAsync<TRequest, TResponse>(
        string endpoint,
        TRequest data,
        CancellationToken cancellationToken = default)
    {
        return await ExecuteWithRetryAsync<TResponse>(
            async () =>
            {
                await SetAuthorizationHeaderAsync(cancellationToken);

                _logger.LogInformation("Calling POST {Endpoint}", endpoint);

                var json = JsonSerializer.Serialize(data, _jsonOptions);
                var content = new StringContent(json, Encoding.UTF8, "application/json");

                var response = await _httpClient.PostAsync(endpoint, content, cancellationToken);
                return await HandleResponseAsync<TResponse>(response, cancellationToken);
            },
            cancellationToken);
    }

    public async Task<TResponse?> PutAsync<TRequest, TResponse>(
        string endpoint,
        TRequest data,
        CancellationToken cancellationToken = default)
    {
        return await ExecuteWithRetryAsync<TResponse>(
            async () =>
            {
                await SetAuthorizationHeaderAsync(cancellationToken);

                _logger.LogInformation("Calling PUT {Endpoint}", endpoint);

                var json = JsonSerializer.Serialize(data, _jsonOptions);
                var content = new StringContent(json, Encoding.UTF8, "application/json");

                var response = await _httpClient.PutAsync(endpoint, content, cancellationToken);
                return await HandleResponseAsync<TResponse>(response, cancellationToken);
            },
            cancellationToken);
    }

    public async Task<bool> DeleteAsync(string endpoint, CancellationToken cancellationToken = default)
    {
        return await ExecuteWithRetryAsync<bool>(
            async () =>
            {
                await SetAuthorizationHeaderAsync(cancellationToken);

                _logger.LogInformation("Calling DELETE {Endpoint}", endpoint);

                var response = await _httpClient.DeleteAsync(endpoint, cancellationToken);

                if (response.IsSuccessStatusCode)
                {
                    return true;
                }

                var error = await response.Content.ReadAsStringAsync(cancellationToken);
                _logger.LogError(
                    "DELETE request failed. Status: {Status}, Error: {Error}",
                    response.StatusCode,
                    error);

                throw new HttpRequestException(
                    $"DELETE request failed with status {response.StatusCode}");
            },
            cancellationToken);
    }

    private async Task<T?> ExecuteWithRetryAsync<T>(
        Func<Task<T>> operation,
        CancellationToken cancellationToken)
    {
        try
        {
            return await operation();
        }
        catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.Unauthorized)
        {
            _logger.LogWarning("Received 401 Unauthorized, refreshing token and retrying...");

            // Refresh token and retry once
            await _tokenService.RefreshTokenAsync(cancellationToken);
            return await operation();
        }
    }

    private async Task SetAuthorizationHeaderAsync(CancellationToken cancellationToken)
    {
        var tokenResponse = await _tokenService.GetAccessTokenAsync(cancellationToken);
        _httpClient.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Bearer", tokenResponse.AccessToken);
    }

    private async Task<T?> HandleResponseAsync<T>(
        HttpResponseMessage response,
        CancellationToken cancellationToken)
    {
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync(cancellationToken);

            if (string.IsNullOrWhiteSpace(content))
            {
                return default;
            }

            try
            {
                var result = JsonSerializer.Deserialize<T>(content, _jsonOptions);
                _logger.LogInformation("Successfully received response");
                return result;
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Failed to deserialize response");
                throw new InvalidOperationException("Failed to deserialize API response", ex);
            }
        }

        var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
        _logger.LogError(
            "API request failed. Status: {Status}, Error: {Error}",
            response.StatusCode,
            errorContent);

        throw new HttpRequestException(
            $"API request failed with status {response.StatusCode}: {errorContent}",
            null,
            response.StatusCode);
    }
}

-----

-- PingIdentityOptions

namespace client_api.Services;

public class PingIdentityOptions
{
    /// <summary>
    /// Ping Identity token endpoint URL
    /// </summary>
    public string TokenEndpoint { get; set; } = string.Empty;

    /// <summary>
    /// OAuth 2.0 Client ID
    /// </summary>
    public string ClientId { get; set; } = string.Empty;

    /// <summary>
    /// JWT Issuer (typically same as ClientId)
    /// </summary>
    public string Issuer { get; set; } = string.Empty;

    /// <summary>
    /// JWT Audience (typically the token endpoint)
    /// </summary>
    public string Audience { get; set; } = string.Empty;

    /// <summary>
    /// Path to the RSA private key file (PEM format)
    /// </summary>
    public string PrivateKeyPath { get; set; } = string.Empty;

    /// <summary>
    /// JWT assertion expiry time in minutes
    /// </summary>
    public int AssertionExpiryMinutes { get; set; } = 5;

    /// <summary>
    /// Space-separated list of scopes to request
    /// </summary>
    public string Scopes { get; set; } = string.Empty;

    /// <summary>
    /// Custom claims to include in the JWT assertion
    /// </summary>
    public Dictionary<string, object> CustomClaims { get; set; } = new();

    /// <summary>
    /// Key ID (kid) for the JWT header (optional)
    /// </summary>
    public string? KeyId { get; set; }

    /// <summary>
    /// Protected API base URL
    /// </summary>
    public string ProtectedApiBaseUrl { get; set; } = string.Empty;
}

-----

-- TokenService

using Microsoft.Extensions.Options;
using System.Text.Json;

namespace client_api.Services;

public interface ITokenService
{
    Task<AccessTokenResponse> GetAccessTokenAsync(CancellationToken cancellationToken = default);
    Task<AccessTokenResponse> RefreshTokenAsync(CancellationToken cancellationToken = default);
}

public class TokenService : ITokenService
{
    private readonly HttpClient _httpClient;
    private readonly IJwtAssertionBuilder _jwtAssertionBuilder;
    private readonly PingIdentityOptions _options;
    private readonly ILogger<TokenService> _logger;

    private AccessTokenResponse? _cachedToken;
    private DateTime _tokenExpiry = DateTime.MinValue;
    private readonly SemaphoreSlim _tokenLock = new(1, 1);

    public TokenService(
        HttpClient httpClient,
        IJwtAssertionBuilder jwtAssertionBuilder,
        IOptions<PingIdentityOptions> options,
        ILogger<TokenService> logger)
    {
        _httpClient = httpClient;
        _jwtAssertionBuilder = jwtAssertionBuilder;
        _options = options.Value;
        _logger = logger;
    }

    public async Task<AccessTokenResponse> GetAccessTokenAsync(CancellationToken cancellationToken = default)
    {
        // Check if we have a valid cached token
        if (_cachedToken != null && DateTime.UtcNow < _tokenExpiry.AddMinutes(-1))
        {
            _logger.LogDebug("Returning cached access token");
            return _cachedToken;
        }

        // Use semaphore to prevent multiple simultaneous token requests
        await _tokenLock.WaitAsync(cancellationToken);
        try
        {
            // Double-check after acquiring lock
            if (_cachedToken != null && DateTime.UtcNow < _tokenExpiry.AddMinutes(-1))
            {
                return _cachedToken;
            }

            _logger.LogInformation("Acquiring new access token from Ping Identity");

            // Build JWT assertion
            var jwtAssertion = _jwtAssertionBuilder.BuildJwtAssertion();

            // Exchange JWT for access token
            var tokenResponse = await ExchangeJwtForAccessTokenAsync(jwtAssertion, cancellationToken);

            // Cache the token
            _cachedToken = tokenResponse;
            _tokenExpiry = DateTime.UtcNow.AddSeconds(tokenResponse.ExpiresIn);

            _logger.LogInformation(
                "Successfully acquired access token. Expires in {ExpiresIn} seconds",
                tokenResponse.ExpiresIn);

            return tokenResponse;
        }
        finally
        {
            _tokenLock.Release();
        }
    }

    public async Task<AccessTokenResponse> RefreshTokenAsync(CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Forcing token refresh");

        // Clear cached token
        _cachedToken = null;
        _tokenExpiry = DateTime.MinValue;

        return await GetAccessTokenAsync(cancellationToken);
    }

    private async Task<AccessTokenResponse> ExchangeJwtForAccessTokenAsync(
        string jwtAssertion,
        CancellationToken cancellationToken)
    {
        var requestParams = new Dictionary<string, string>
        {
            ["grant_type"] = "client_credentials",
            ["client_assertion_type"] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
            ["client_assertion"] = jwtAssertion
        };

        // Add scopes if specified
        if (!string.IsNullOrWhiteSpace(_options.Scopes))
        {
            requestParams["scope"] = _options.Scopes;
        }

        var requestContent = new FormUrlEncodedContent(requestParams);

        try
        {
            _logger.LogDebug("Sending token request to {Endpoint}", _options.TokenEndpoint);

            var response = await _httpClient.PostAsync(
                _options.TokenEndpoint,
                requestContent,
                cancellationToken);

            var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Token request failed. Status: {StatusCode}, Response: {Response}",
                    response.StatusCode,
                    responseContent);

                throw new HttpRequestException(
                    $"Token request failed with status {response.StatusCode}: {responseContent}");
            }

            var tokenResponse = JsonSerializer.Deserialize<AccessTokenResponse>(
                responseContent,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (tokenResponse == null || string.IsNullOrEmpty(tokenResponse.AccessToken))
            {
                throw new InvalidOperationException("Invalid token response from Ping Identity");
            }

            return tokenResponse;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error while requesting access token");
            throw new InvalidOperationException("Failed to communicate with Ping Identity", ex);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "Failed to parse token response");
            throw new InvalidOperationException("Invalid token response format", ex);
        }
    }
}

public class AccessTokenResponse
{
    public string AccessToken { get; set; } = string.Empty;
    public string TokenType { get; set; } = "Bearer";
    public int ExpiresIn { get; set; }
    public string? Scope { get; set; }
    public string? RefreshToken { get; set; }
}


-----
-- JwtAssertionBuilder

using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;

namespace client_api.Services;

public interface IJwtAssertionBuilder
{
    string BuildJwtAssertion();
}

public class JwtAssertionBuilder : IJwtAssertionBuilder
{
    private readonly PingIdentityOptions _options;
    private readonly ILogger<JwtAssertionBuilder> _logger;
    private RSA? _rsa;

    public JwtAssertionBuilder(
        IOptions<PingIdentityOptions> options,
        ILogger<JwtAssertionBuilder> logger)
    {
        _options = options.Value;
        _logger = logger;
    }

    public string BuildJwtAssertion()
    {
        try
        {
            // Load private key if not already loaded
            _rsa ??= LoadPrivateKey();

            var signingCredentials = new SigningCredentials(
                new RsaSecurityKey(_rsa),
                SecurityAlgorithms.RsaSha256)
            {
                CryptoProviderFactory = new CryptoProviderFactory { CacheSignatureProviders = false }
            };

            var now = DateTime.UtcNow;
            var jti = Guid.NewGuid().ToString();

            // Build claims list
            var claims = new List<Claim>
            {
                new Claim(JwtRegisteredClaimNames.Iss, _options.ClientId),
                new Claim(JwtRegisteredClaimNames.Sub, _options.ClientId),
                new Claim(JwtRegisteredClaimNames.Aud, _options.TokenEndpoint),
                //new Claim(JwtRegisteredClaimNames.Exp, new DateTimeOffset(now).ToUnixTimeSeconds().ToString()),
                new Claim(JwtRegisteredClaimNames.Jti, jti),
                new Claim(JwtRegisteredClaimNames.Iat, new DateTimeOffset(now).ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
            };

            // Add custom claims
            foreach (var customClaim in _options.CustomClaims)
            {
                if (customClaim.Value is string stringValue)
                {
                    claims.Add(new Claim(customClaim.Key, stringValue));
                }
                else if (customClaim.Value is int intValue)
                {
                    claims.Add(new Claim(customClaim.Key, intValue.ToString(), ClaimValueTypes.Integer));
                }
                else if (customClaim.Value is bool boolValue)
                {
                    claims.Add(new Claim(customClaim.Key, boolValue.ToString().ToLower(), ClaimValueTypes.Boolean));
                }
                else
                {
                    claims.Add(new Claim(customClaim.Key, customClaim.Value?.ToString() ?? string.Empty));
                }
            }

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = now.AddMinutes(_options.AssertionExpiryMinutes),
                //IssuedAt = now,
                //NotBefore = now,
                //Issuer = _options.Issuer,
                //Audience = _options.Audience,
                SigningCredentials = signingCredentials
            };

            var tokenHandler = new JwtSecurityTokenHandler();
            var token = tokenHandler.CreateToken(tokenDescriptor);

            // Add kid to header if specified
            if (!string.IsNullOrEmpty(_options.KeyId))
            {
                var jwtToken = token as JwtSecurityToken;
                if (jwtToken != null)
                {
                    jwtToken.Header.Add("kid", _options.KeyId);
                }
            }

            var jwtAssertion = tokenHandler.WriteToken(token);

            _logger.LogInformation(
                "Created JWT assertion. JTI: {Jti}, Expires: {Expires}, Claims: {ClaimCount}",
                jti, tokenDescriptor.Expires, claims.Count);

            return jwtAssertion;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to build JWT assertion");
            throw new InvalidOperationException("Failed to build JWT assertion", ex);
        }
    }

    private RSA LoadPrivateKey()
    {
        try
        {
            if (!File.Exists(_options.PrivateKeyPath))
            {
                throw new FileNotFoundException(
                    $"Private key file not found at: {_options.PrivateKeyPath}");
            }

            var pemContent = File.ReadAllText(_options.PrivateKeyPath);
            var rsa = RSA.Create();

            // Remove PEM headers/footers and whitespace
            var base64 = pemContent
                .Replace("-----BEGIN PRIVATE KEY-----", "")
                .Replace("-----END PRIVATE KEY-----", "")
                .Replace("-----BEGIN RSA PRIVATE KEY-----", "")
                .Replace("-----END RSA PRIVATE KEY-----", "")
                .Replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "")
                .Replace("-----END ENCRYPTED PRIVATE KEY-----", "")
                .Replace("\n", "")
                .Replace("\r", "")
                .Replace(" ", "")
                .Trim();

            if (string.IsNullOrWhiteSpace(base64))
            {
                throw new InvalidOperationException("Private key file is empty or invalid");
            }

            var keyBytes = Convert.FromBase64String(base64);

            // Try different key formats
            try
            {
                // Try PKCS#8 format first (most common)
                rsa.ImportPkcs8PrivateKey(keyBytes, out _);
                _logger.LogInformation("Loaded private key in PKCS#8 format from {Path}", _options.PrivateKeyPath);
            }
            catch
            {
                try
                {
                    // Try RSA format
                    rsa.ImportRSAPrivateKey(keyBytes, out _);
                    _logger.LogInformation("Loaded private key in RSA format from {Path}", _options.PrivateKeyPath);
                }
                catch
                {
                    // Try encrypted PKCS#8
                    throw new InvalidOperationException(
                        "Unable to import private key. Ensure it's in PKCS#8 or RSA format and not encrypted.");
                }
            }

            return rsa;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load private key from {Path}", _options.PrivateKeyPath);
            throw new InvalidOperationException($"Failed to load private key: {ex.Message}", ex);
        }
    }
}

----
// Configure HttpClient with proper timeout
builder.Services.AddHttpClient<ITokenService, TokenService>()
    .ConfigureHttpClient(client =>
    {
        client.Timeout = TimeSpan.FromSeconds(30);
    });

builder.Services.AddHttpClient<IProtectedApiClient, ProtectedApiClient>()
    .ConfigureHttpClient(client =>
    {
        client.Timeout = TimeSpan.FromSeconds(30);
    });

// Register services
builder.Services.AddSingleton<ITokenService, TokenService>();
builder.Services.AddSingleton<IJwtAssertionBuilder, JwtAssertionBuilder>();
builder.Services.AddScoped<IProtectedApiClient, ProtectedApiClient>();

// Configure options
builder.Services.Configure<PingIdentityOptions>(
    builder.Configuration.GetSection("PingIdentity"));
----
"PingIdentity": {
  "TokenEndpoint": "https://.com/am/oauth2/alpha/access_token",
  "ClientId": "",
  "Issuer": "",
  "Audience": "https:///am/oauth2/alpha/access_token",
  "PrivateKeyPath": "//private_key.pem",
  "AssertionExpiryMinutes": 5,
  "Scopes": "openid profile api.read api.write",
  "KeyId": "",
  "ProtectedApiBaseUrl": "https://your-protected-api.com",
  "CustomClaims": {

  }
},

----